IntBst:
  implement java Collection, Set, Iterable
  add equality method

Interfaces:
  Seq: Add default implementation for java Collection and List

Build:
  make rake use the jruby nailgun server

Tests:
  add contract test, for now as ruby module for every contracts and their mixes


class package organization:

gen: Col, Red, Builder, Seq, Vec, Set, Fun, Sorted
int: IntCol, IntRed, IntBuilder, IntSeq, IntVec, IntSet, IntFun, IntSorted
  IntHashSet: never cares about collision
  IntVec = Int to Int Fun
long: ? LongCol, LongVec, LongSeq, LongReD
double: ? DoubleCol, DoubleVec, DoubleSeq, DoubleRed

plus other combinations:
  Heap, BinHeap, RBTreeSet, RBTreeMap, HashSetTrie, HashMapTrie, Splay, Queue


how to separate ?

by types ?
  import jpfds.gen.{Col, Red, Builder, Seq, Vec}
  import jpfds.ints.{IntCol, IntRed, IntSeq, IntBuilder}

by collections ?
  import jpfds.vecs.{Vec, IntVec, DoubleVec, LongVec, + builders, ... }
  import jpfds.sets.{TreeSet, HashTrieSet, IntTreeSet, IntSet, ... }
  import jpfds.funs.{TreeMap, HashTrieMap, ... }
  import jpfds.seqs.{SeqBuilder, Seq, EmptySeq, ... }
  import jpfds.{Col, Reducer, Builder, IntCol, IntReducer, IntBuilder, ... }

  but Seq, Vec, Fun are more fundamental

by implementation ?

  import jpfds.hashtries.{HashTrieSet, HashTrieMap, Vector, ... }
  import jpfds.trees.{TreeSet, TreeMap, IntTreeSet, ... }
  import jpfds.seqs.{EmptySeq, ... }
  import jpfds.base.{Col, Reducer, Builder} x 4 types
  import jpfds.{Vec, Seq, Set, Fun} x 4 types + SizeInfo

by implementation + types

  import jpfs.{Vec, Seq, Set, Fun, SizeInfo, Col, Reducer, Builder}
  import jpfds.seqs.{SeqBuilder, EmptySeq, List, ... } x 4 types
