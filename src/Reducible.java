/*----------------------------------------------------------------------------*
 *              Copyright (c) Hugo Benichi. All right reserved.               *
 *----------------------------------------------------------------------------*/

package jpfds;

import java.util.function.Function;
import java.util.function.BiFunction;
import java.util.function.Predicate;

/** An abstract source of elements that supports lazy bulk operations. A
 *  concrete collection can extend Reducible and expose a lazy view of itself
 *  by providing a way to traverse its internal structure and input its elements
 *  into a reducer function. Lazy bulk operations create new Reducible views
 *  pinned to this initial concrete collection. A traversal of the inital source
 *  is triggered by a reducing operation or a building operation. Building a new
 *  collection from a Reducible is not affected by the properties of the initial
 *  source. E.g building a Seq from a Set does not eliminate final duplicates
 *  that intermediary reducing operations such as map() may produce.
 *  @param <X> type of the elements produced by this Reducible. */
public interface Reducible<X> {

  /** Traverses the Reducible and inputs its elements into a reducer function
   *  to produce a value.
   *  @param seed an initial value for the accumulator.
   *  @param f a binary reducing function that knows how to input elements
   *  served by this Reducible into the accumulator.
   *  @param <Y> type of the accumulator.
   *  @return the result of applying repeatidly the reducing function onto the
   *  accumulator using elements served by this Reducible. */
  <Y> Y reduce(Y seed, BiFunction<Y, ? super X,Y> f);

  /** Constructs a collection using this Reducible as a source.
   *  @param col an initial collection value. Cannot be null.
   *  @param <C> concrete type of the output collection.
   *  @return the resulting collection after adding elements produced by this Reducible. */
  default <C extends Col<X,C>> C into(C col) {
    return this.reduce(col, Col::addTo);
  }

  /** Constructs a collection from a Builder using this Reducible as a source.
   *  @param bld a collection builder. Cannot be null.
   *  @param <C> concrete type of the output collection to build.
   *  @return the resulting collection after adding elements produced by this Reducible. */
  default <C extends Col<X,C>> C into(Builder<X,C> bld) {
    return this.reduce(bld, Builder::addTo).make();
  }

  /** Creates a new Reducible using a unary mapping function.
   *  @param f a unary mapping function. Cannot be null.
   *  @param <Y> the output type of the mapping function.
   *  @return a Reducible that produces elements sourced by the original
   *  Reducible object with the mapping function applied on them. */
  default <Y> Reducible<Y> map(final Function<? super X,Y> f) {
    final Reducible<X> source = this;
    return new Reducible<Y>() {
      public <Z> Z reduce(Z seed, BiFunction<Z, ? super Y,Z> g) {
        return source.reduce(seed, (col,e) -> g.apply(col, f.apply(e)));
      }
    };
  }

  /** Creates a new Reducible using a unary mapping function that itself
   *  generates Reducible.
   *  @param f a unary mapping function. Cannot be null.
   *  @param <Y> the output type of elements produced by the Reducible objects
   *  made by the mapping function.
   *  @return a Reducible that collects all elements of all Reducible objects
   *  generated by the mapping function. */
  default <Y> Reducible<Y> flatMap(final Function<? super X,Reducible<Y>> f) {
    final Reducible<X> source = this;
    return new Reducible<Y>() {
      public <Z> Z reduce(Z seed, BiFunction<Z, ? super Y,Z> g) {
        return source.reduce(seed, (col,e) -> f.apply(e).reduce(col, g));
      }
    };
  }

  /** Filters elements of this Reducible using a predicate function.
   *  @param f a boolean predicate. Cannot be null.
   *  @return a new Reducible that only sources elements of the initial
   *  Reduciblefor for which the predicate will return true. */
  default Reducible<X> filter(Predicate<? super X> f) {
    final Reducible<X> source = this;
    return new Reducible<X>() {
      public <Y> Y reduce(Y seed, BiFunction<Y, ? super X,Y> g) {
        return source.reduce(seed,
          (col,e) -> {
            if (f.test(e)) return g.apply(col,e); else return col;
          }
        );
      }
    };
  }
}
