package jpfds;

import java.util.function.Function;
import java.util.function.BiFunction;
import java.util.function.Predicate;

/** An abstract source of elements that supports lazy bulk operations. A
 *  concrete collection can extend Reducible and expose a lazy view of itself
 *  by providing a way to traverse its internal structure and input its elements
 *  into a reducer function. Lazy bulk operations create new Reducible views
 *  pinned to this initial concrete collection. A traversal of the inital source
 *  is triggered by a reducing operation or a building operation. Building a new
 *  collection from a Reducible is not affected by the properties of the initial
 *  source. E.g building a Seq from a Set does not eliminate final duplicates
 *  that intermediary reducing operations such as map() may produce.
 *  @param <X> type of the elements produced by this Reducible. */
public interface Reducible<X> {

  /** Traverses the Reducible and inputs its elements into a reducer function
   *  to produce a value.
   *  @param seed an initial value for the accumulator.
   *  @param f a binary reducing function that knows how to input elements
   *  served by this Reducible into the accumulator.
   *  @param <Y> type of the accumulator.
   *  @return the result of applying repeatidly the reducing function onto the
   *  accumulator using elements served by this Reducible. */
  <Y> Y reduce(Y seed, BiFunction<Y, ? super X,Y> f);

  /** Constructs a collection using this Reducible as a source.
   *  @param col an initial collection value. Cannot be null.
   *  @param <C> concrete type of the output collection.
   *  @return the resulting collection after adding elements produced by this Reducible. */
  default <C extends Col<X,C>> C into(C col) {
    return this.reduce(col, Col::addTo);
  }

  /** Constructs a collection from a Builder using this Reducible as a source.
   *  @param bld a collection builder. Cannot be null.
   *  @param <C> concrete type of the output collection to build.
   *  @return the resulting collection after adding elements produced by this Reducible. */
  default <C extends Col<X,C>> C into(Builder<X,C> bld) {
    return this.reduce(bld, Builder::addTo).make();
  }

  /** Creates a new Reducible using a unary mapping function.
   *  @param f a unary mapping function. Cannot be null.
   *  @param <Y> the output type of the mapping function.
   *  @return a Reducible that produces elements with the mapping function applied on */
  default <Y> Reducible<Y> map(final Function<? super X,Y> f) {
    final Reducible<X> source = this;
    return new Reducible<Y>() {
      public <Z> Z reduce(Z seed, BiFunction<Z, ? super Y,Z> g) {
        return source.reduce(seed, (col,e) -> g.apply(col, f.apply(e)));
      }
    };
  }

  /** Creates a new Reducible using a unary mapping function that itself
   *  generates Reducible.
   *  @param f a unary mapping function. Cannot be null.
   *  @param <Y> the output type of elements produced by the Reducible objects
   *  made by the mapping function.
   *  @return a Reducible that collects all elements of all Reducible objects
   *  generated by the mapping function. */
  default <Y> Reducible<Y> flatMap(final Function<? super X,Reducible<Y>> f) {
    final Reducible<X> source = this;
    return new Reducible<Y>() {
      public <Z> Z reduce(Z seed, BiFunction<Z, ? super Y,Z> g) {
        return source.reduce(seed, (col,e) -> f.apply(e).reduce(col, g));
      }
    };
  }

  /** Filters elements of this Reducible using a predicate function.
   *  @param f a boolean predicate. Cannot be null.
   *  @return a new Reducible that only sources elements of the initial
   *  Reduciblefor for which the predicate will return true. */
  default Reducible<X> filter(Predicate<? super X> f) {
    final Reducible<X> source = this;
    return new Reducible<X>() {
      public <Y> Y reduce(Y seed, BiFunction<Y, ? super X,Y> g) {
        return source.reduce(seed,
          (col,e) -> {
            if (f.test(e)) return g.apply(col,e); else return col;
          }
        );
      }
    };
  }

  /** Keep the first n elements of this Reducible.
   *  should override the default implementation.
   *  @param n the number of initial elements to keep.
   *  @return a Reducible that stops after producing the n first initial
   *  elements from this Reducible. */
  default Reducible<X> take(final int n) {
    final Reducible<X> source = this;
    return new Reducible<X>() {
      public <Y> Y reduce(Y seed, BiFunction<Y, ? super X,Y> g) {
        Predicate<X> counter = new Predicate<X>() {
          int left = n;
          public boolean test(X elem) { return left-- > 0; }
        };
        return source.filter(counter).reduce(seed, g);
      }
    };
  }

  /** Skips the n first elements of this Reducible. Concrete implementation
   *  should override the default implementation.
   *  @param n the number of initial elements to skip.
   *  @return a Reducible that skips the n first initial elements of this
   *  Reducible. */
  default Reducible<X> skip(int n) {
    final Reducible<X> source = this;
    return new Reducible<X>() {
      public <Y> Y reduce(Y seed, BiFunction<Y, ? super X,Y> g) {
        Predicate<X> counter = new Predicate<X>() {
          int left = n;
          public boolean test(X elem) { return left-- <= 0; }
        };
        return source.filter(counter).reduce(seed, g);
      }
    };
  }

  /** Keep elements from this Reducible until the predicate holds true.
   *  @param f a boolean predicate. Cannot be null.
   *  @return a Reducible that stops at the first failure of the predicate. */
  default Reducible<X> until(final Predicate<X> f) {
    final Reducible<X> source = this;
    return new Reducible<X>() {
      public <Y> Y reduce(Y seed, BiFunction<Y, ? super X,Y> g) {
        Predicate<X> transition = new Predicate<X>() {
          boolean until = true;
          public boolean test(X elem) { return until = until & f.test(elem); }
        };
        return source.filter(transition).reduce(seed, g);
      }
    };
  }

  /** Skip elements from this Reducible until the predicate holds false.
   *  @param f a boolean predicate. Cannot be null.
   *  @return a Reducible that skips elements until the first success of the
   *  predicate.*/
  default Reducible<X> from(final Predicate<X> f) {
    final Reducible<X> source = this;
    return new Reducible<X>() {
      public <Y> Y reduce(Y seed, BiFunction<Y, ? super X,Y> g) {
        Predicate<X> transition = new Predicate<X>() {
          boolean until = false;
          public boolean test(X elem) { return until = until | f.test(elem); }
        };
        return source.filter(transition).reduce(seed, g);
      }
    };
  }
}

/* NOTES:

The implementation of take/skip/drop cannot take advantage of any knowledge of
the initial collection. As soon as a map operation is performed, the new
Reducible has forgotten about its concrete type. The consequence is that the
default implementation of these take/skip like functions cannot work without
allocating a counting statefull filter that is blind to the original collection.

How to solve this ? The root of the problem is that the range of reduce() cannot
be controlled by the final build operation. How to provide an interface to
control this wihtout making it too heavyweight ?
*/
