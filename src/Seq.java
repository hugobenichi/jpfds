/*----------------------------------------------------------------------------*
 *              Copyright (c) Hugo Benichi. All right reserved.               *
 *----------------------------------------------------------------------------*/

package jpfds;

import java.util.Objects;
import java.util.Iterator;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;

import jpfds.seqs.LazySeq;

/** Abstraction of a linear data structure that has efficient access and
 *  append at its front. A Seq is a specialization of the Col abstraction. It
 *  implements the Reducible abstraction and is also an Iterable. Concrete
 *  implementations provide strict linked list or lazy and potentially infinite
 *  Seq specializations. */
public interface Seq<X> extends Iterable<X>, Col<X,Seq<X>> {

  Seq<X> tail();
  X head();

  default Seq<X> seq() { return this; }
  default Seq<X> cons(X elem) { return Seqs.cons(elem, this); }
  default Seq<X> add(X elem) { return this.cons(elem); }
  default Seq<X> empty() { return Seqs.nil(); }
  default Seq<X> union(Seq<X> that) {
    return Seqs.<X>builder().addAllThen(this).addAllThen(that).make();
  }

  /** Returns true if this Seq is equal to the given Seq. Two Seqs are equal if
   *  they contain equal elements in the same order. This operation is strict
   *  and does not terminate when called on an infinite Seq.
   *  @param that any Seq. Cannot be null.
   *  @return true if both Seqs are equal, false otherwise. */
  default boolean eq(Seq<X> that) {
    if (this == that) return true;
    if (that.isEmpty()) return this.isEmpty();
    if (this.isEmpty()) return false;
    return Objects.equals(this.head(), that.head())
      && this.tail().eq(that.tail());
  }

  default Iterator<X> iterator() {
    final Seq<X> self = this;
    return new Iterator<X>() {
      Seq<X> seq = self;
      public void remove() { throw removeException; }
      public boolean hasNext() { return seq.nonEmpty(); }
      public X next() {
        X nextValue = seq.head();
        seq = seq.tail();
        return nextValue;
      }
    };
  }

  default Size sizeInfo() { return Size.unknown; }

  default int size() { return this.reduce(0, (l,x) -> l + 1); }

  default <Y> Y reduce(Y seed, BiFunction<Y, ? super X,Y> f) {
    Seq<X> seq = this;
    while (seq.nonEmpty()) {
      seed = f.apply(seed, seq.head());
      seq = seq.tail();
    }
    return seed;
  }

  /** Reverses this Seq. This operation is strict and does not terminate when
   *  called on an infinite Seq.
   *  @return a Seq that contains all elements of this Seq in reverse order. */
  default Seq<X> reverse() { return this.reduce(empty(), (s,x) -> s.cons(x)); }

  /** Creates the Seq which is the concatenation of this Seq and the given Seq.
   *  @param right any Seq. Cannot be null.
   *  @return a lazy Seq that produces all elements of this Seq and then all
   *  elements of the given Seq. */
  default Seq<X> lcat(final Seq<X> right) {
    final Seq<X> left = this;
    return new LazySeq<X>() {
      protected void advance() {
        if (left.nonEmpty())
          setTo(left.head(), left.tail().lcat(right));
        else if (right.nonEmpty())
          setTo(right.head(), right.tail());
        else
          setEmpty();
      }
    };
  }

  /** Creates a new Seq using a unary mapping function.
   *  @param f a unary mapping function. Cannot be null.
   *  @param <Y> the output type of the mapping function.
   *  @return a lazy Seq that contains elements made from the mapping function
   *  applie onto the elements contains in this Seq, preserving order. */
  default <Y> Seq<Y> lmap(final Function<X,Y> f) {
    final Seq<X> source = this;
    return new LazySeq<Y>() {
      protected void advance() {
        if (source.isEmpty())
          setEmpty();
        else
          setTo(f.apply(source.head()), source.tail().lmap(f));
      }
    };
  }

  /** Creates a new Seq using a unary mapping function that generates Seq.
   *  @param f a unary mapping function. Cannot be null.
   *  @param <Y> the output type of elements produced by the Seq objects made
   *  by the mapping function.
   *  @return a lazy Seq that collects and flattens all elements of all Seq
   *  objects generated by the mapping function. */
  default <Y> Seq<Y> lflatMap(final Function<X,Seq<Y>> f) {
    final Seq<X> source = this;
    return new LazySeq<Y>() {
      protected void advance() {
        for (Seq<X> s = source; s.nonEmpty(); s = s.tail()) {
          Seq<Y> front = f.apply(s.head());
          if (front.nonEmpty()) {
            setTo(front.head(), front.tail().lcat(s.tail().lflatMap(f)));
            return;
          }
        }
        setEmpty();
      }
    };
  }

  /** Filters elements of this Seq using a predicate function.
   *  @param f a boolean predicate. Cannot be null.
   *  @return a lazy Seq that only contains elements of this Seq for which the
   *  predicate returns true. */
  default Seq<X> lfilter(final Predicate<X> f) {
    final Seq<X> source = this;
    return new LazySeq<X>() {
      protected void advance() {
        for (Seq<X> s = source; s.nonEmpty(); s = s.tail()) {
          if (f.test(s.head())) {
            setTo(s.head(), s.tail().lfilter(f));
            return;
          }
        }
        setEmpty();
      }
    };
  }

  /** Keep the first n elements of this Seq.
   *  @param n the number of initial elements to keep.
   *  @return a lazy Seq that stops after producing the n first initial
   *  elements of this Seq. */
  default Seq<X> take(final int n) {
    if (n <= 0) return empty();
    final Seq<X> source = this;
    return new LazySeq<X>() {
      protected void advance() {
        if (source.nonEmpty())
          setTo(source.head(), source.tail().take(n-1));
        else
          setEmpty();
      }
    };
  }

  /** Skips the n first elements of this Seq.
   *  @param n the number of initial elements to skip.
   *  @return a lazy Seq that skips the n first initial elements of this Seq. */
  default Seq<X> skip(final int n) {
    if (n <= 0) return this;
    final Seq<X> source = this;
    return new LazySeq<X>() {
      protected void advance() {
        Seq<X> s = source;
        for (int c = n; c > 0 && s.nonEmpty(); c--) { s = s.tail(); }
        if (s.nonEmpty()) setTo(s.head(), s.tail()); else setEmpty();
      }
    };
  }

  /** Keep returning elements from this Seq until the predicate holds true.
   *  @param f a boolean predicate. Cannot be null.
   *  @return a lazy Seq that stops at the first failure of the predicate. */
  default Seq<X> until(final Predicate<X> f) {
    final Seq<X> source = this;
    return new LazySeq<X>() {
      protected void advance() {
        if (source.nonEmpty() && f.test(source.head()))
          setTo(source.head(), source.tail().until(f));
        else
          setEmpty();
      }
    };
  }

  RuntimeException removeException =
    new UnsupportedOperationException("Seq Iterators do not support remove().");

  RuntimeException emptyHeadException =
    new UnsupportedOperationException("An empty seq has no head.");

  RuntimeException emptyTailException =
    new UnsupportedOperationException("An empty seq has no tail.");

}
